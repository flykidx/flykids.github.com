<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Thread dead loop -- register variable</title>
    <link href="/2022/09/09/thread-dead-loop/"/>
    <url>/2022/09/09/thread-dead-loop/</url>
    
    <content type="html"><![CDATA[<p>When I was a student many years ago, the teacher described the difference between <strong>register</strong> variables and <strong>volatile</strong> variables in detail. At that time, I thought it was just two keywords of C language, which were rarely used, so I didn’t pay much attention to them. With more and more work experience, I realized that these two ordinary guys have a lot of articles, and their existence means a contest between program <strong>performance</strong> and <strong>reliability</strong>.</p><h3 id="Problem-backgourd"><a href="#Problem-backgourd" class="headerlink" title="Problem backgourd"></a>Problem backgourd</h3><p>I am work at Tencent GVoice team since 2015. GVoice is voice-chat cross-platform SDK, serving 500+ games, 300 million active users. </p><p>Recently I found a strange problem, many users feedback that cannot open the microphone occasionally, <strong><font color="red">team members cannot hear his voice</font></strong>, but he can hear team members’ voice. </p><p>Allow me to introduce the steps to using voice-chat function: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.Join team room; <br>2.Open microphone and speaker; <br>3.The captured voice data is forwarded to other team members through the RTC server. <br></code></pre></td></tr></table></figure><h3 id="Problem-analysis"><a href="#Problem-analysis" class="headerlink" title="Problem analysis"></a>Problem analysis</h3><p>Cannot-Hearing is a common problem in RTC-over-voice application. In 2019, I designed a Full-link QoS system to locate the cause of these probloms. The idea is as below:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.Tracing API Callings;<br>2.Tracing recording pipline(capture-&gt;resample-&gt;3A-&gt;mix-&gt;encode-&gt;pack-&gt;FEC-&gt;room-out);<br>3.Tracing voice data<span class="hljs-string">&#x27;s uplink, forwarding, and downlink;</span><br><span class="hljs-string">4.Tracing playing pipline(room-in-&gt;Dmx-&gt;deFEC-&gt;unpack-&gt;JB-&gt;decode-&gt;resample-&gt;mix-&gt;render).</span><br></code></pre></td></tr></table></figure><p>Through the Full-link QoS system, I located that <strong>the event of opening micphone was not processed by work thread, and the tick count of work thread is 0</strong>. so, was the work thread blocked or dead? This problom is set aside until opening LTO to optimize package size, aha, it was occurred again.</p><p>I dumped the thread call stack, found that the work thread run into loop code and cannot jump out. loop condition is a globle register variable.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">SDK initialization call:<br>    int CEngine::<span class="hljs-function"><span class="hljs-title">StartEngine</span></span>()<br>    &#123;<br>    ...<br>        m_RecvProc.Start();<br>        m_thCapture.Start();<br>        m_thRender.Start();<br>        ...<br>        GetCtx()-&gt;bEngineStart = <span class="hljs-literal">true</span>;<br>        ...<br>    &#125;<br><br>Work thread call:<br>    int ThreadCapture::<span class="hljs-function"><span class="hljs-title">SysThreadProc</span></span>()<br>    &#123;<br>        ...<br>        //loop code to <span class="hljs-built_in">wait</span> the end of initialization<br>        <span class="hljs-keyword">while</span>(!GetCtx()-&gt;bEngineStart)<br>        &#123;<br>            SysSleep(5);<br>            <span class="hljs-built_in">continue</span>;<br>        &#125;<br>        //process cmd and task.<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure><p>We known that thread sleeping will causes cached values to be reloaded. the register value of bEngineStart will be update after next thread tick when initialize complete. The bad news is <strong>SysSleep function is empty implementation under Android platform</strong>, causes the cpu that assiciated work thead to run at 100%, <strong>no chance to update cached register value</strong>, so the work thread register value of bEngineStart is always false.</p><p>So, Why does this problem occur at low frequencies, but it inevitably happens when LTO is enabled? usually, user thread sets bEngineStart to ture firstly, and then work thread jumps over the loop code. But, if user thread is blocked a short time(Enalbe LTO), work thread has start up firstly, and bEngineStart is still false, although user thread will set it to true later, but work thread has no chance to update it from memory.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">SDK initialization call:<br>    int CEngine::<span class="hljs-function"><span class="hljs-title">StartEngine</span></span>()<br>    &#123;<br>    ...<br>        m_RecvProc.Start();<br>        m_thCapture.Start();<br>        //!!!here blocked a short time<br>        m_thRender.Start();<br>        ...<br>        GetCtx()-&gt;bEngineStart = <span class="hljs-literal">true</span>;<br>        ...<br>    &#125;<br><br>Work thread call:<br>    int ThreadCapture::<span class="hljs-function"><span class="hljs-title">SysThreadProc</span></span>()<br>    &#123;<br>        ...<br>        //register of bEngineStart is always <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">while</span>(!GetCtx()-&gt;bEngineStart)<br>        &#123;<br>            SysSleep(5);<br>            <span class="hljs-built_in">continue</span>;<br>        &#125;<br>        //process cmd and task.<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure><p>Therefore, user thread blocking or just being switched will cause the above problem.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>SysSleep is an old version of thread sleeping implementation, new version Sleep function implementation is platform-wide, replace it with the new verion! Some code logic usually has a small probability of running, and is often the source of the bugs.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
